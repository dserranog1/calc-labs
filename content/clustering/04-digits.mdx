---
title: Digits MINST
sidebarTitle: Digits MINST
---

<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex/dist/katex.css"
/>

## üßæ Nuestro conjunto de datos: d√≠gitos escritos a mano

Hoy trabajaremos con un conjunto real de datos llamado **Digits MNIST**.  
Contiene im√°genes peque√±as de **n√∫meros del 0 al 9**, escritas a mano por distintas personas.

Pero antes de usar estas im√°genes para hacer clustering, deteng√°monos a entender c√≥mo se representa una imagen dentro de un computador.

---

### üñºÔ∏è ¬øQu√© es una imagen digital?

Una imagen digital est√° formada por **una cuadr√≠cula de p√≠xeles**.  
Cada p√≠xel es una peque√±a unidad que tiene un color o nivel de intensidad.

En el caso de **im√°genes en escala de grises**, cada p√≠xel se representa por **un solo n√∫mero** que indica qu√© tan claro u oscuro es ese punto:

- Un valor **bajo** (cerca de 0) representa un p√≠xel negro.
- Un valor **alto** (cerca de 16 o 255, seg√∫n el rango) representa un p√≠xel blanco.

---

### üßÆ Nuestro caso: im√°genes de 8√ó8

En el conjunto **Digits MNIST**, cada imagen tiene tama√±o **8 filas √ó 8 columnas**.  
Es decir, una cuadr√≠cula de 64 p√≠xeles en total.

Cada imagen se puede ver como una matriz:

```python
[
  [0, 0, 2, 13, 5, 0, 0, 0],
  [0, 0, 13, 15, 10, 0, 0, 0],
  [0, 3, 15, 7, 0, 0, 0, 0],
  ...
]
```

Esta matriz representa c√≥mo se ve el n√∫mero ‚Äú3‚Äù desde el punto de vista de la m√°quina.

---

### üß† ¬øQu√© hace la computadora con esta matriz?

Para procesarla, la computadora **no ve una imagen**.  
Lo que hace es **convertir esta matriz en una lista de n√∫meros**: un vector con 64 valores.

```python
[0, 0, 2, 13, 5, 0, 0, 0, 0, 0, 13, 15, 10, 0, 0, 0, ..., 0]
```

Este vector es lo que usamos como entrada para los algoritmos de machine learning.

> Cada imagen es, entonces, **un punto en un espacio de 64 dimensiones**.

Y ese ser√° el punto de partida para lo que viene a continuaci√≥n.


### üì∑ Visualizando una imagen creada a mano

Veamos c√≥mo se construye una imagen digital simple desde una matriz de n√∫meros.

```python
import matplotlib.pyplot as plt
import numpy as np

# Imagen 8x8 que representa un "3"
image = np.array([
    [16, 16,  4,  2,  2,  4, 16, 16],
    [16, 10, 16, 16, 16, 16,  6, 16],
    [16, 16, 16, 16, 16, 16,  6, 16],
    [16, 16,  8,  8,  8,  8, 16, 16],
    [16, 16, 16, 16, 16, 16,  6, 16],
    [16,  8, 16, 16, 16, 16,  6, 16],
    [16, 16,  4,  4,  4,  4, 16, 16],
    [16, 16, 16, 16, 16, 16, 16, 16],
])

# Mostrar la matriz
print("Matriz de intensidades (0 = negro, 16 = blanco):")
print(image)

# Visualizar la imagen (invertimos el mapa de colores para que 0 sea negro)
plt.imshow(image, cmap="gray_r", interpolation="nearest")
plt.title("D√≠gito 3 hecho a mano")
plt.axis("off")
plt.show()
```

> Esta imagen es una cuadr√≠cula de 8x8 p√≠xeles.  
> Cada n√∫mero representa el nivel de intensidad en escala de grises:  
> cuanto m√°s alto el n√∫mero, m√°s claro el p√≠xel.


### üî¢ De imagen a vector

Para que los algoritmos de machine learning puedan procesar una imagen, deben convertirla en una **estructura que puedan manipular matem√°ticamente**: un vector.

> La imagen de 8√ó8 se transforma en un vector de 64 n√∫meros:  
> simplemente se ‚Äúaplanan‚Äù las filas una tras otra.

```python
# Aplanar la imagen a un vector de 64 dimensiones
vector = image.flatten()

# Mostrar el vector resultante
print("Vector plano de la imagen (longitud 64):")
print(vector)
```

Este vector representa un **punto en un espacio de 64 dimensiones**.  
Cada componente del vector corresponde a la intensidad de un p√≠xel.

> La computadora **no ‚Äúve‚Äù una imagen como nosotros**, sino como una lista de n√∫meros que pueden ser comparados, agrupados o analizados.

As√≠ es como las im√°genes entran al mundo del c√°lculo y el √°lgebra lineal: como vectores de alta dimensi√≥n.


## üîÅ Recapitulaci√≥n: de imagen a aprendizaje autom√°tico

Hasta ahora, hemos construido a mano una imagen del n√∫mero **3**, representada como una cuadr√≠cula de p√≠xeles en escala de grises.  
Esa imagen, para la m√°quina, no es m√°s que una **matriz de n√∫meros**.

Convertimos esa matriz en un **vector de 64 componentes**:  
un punto en un espacio de 64 dimensiones.

---

### ü§ñ ¬øQu√© busca hacer el aprendizaje autom√°tico con ese vector?

El aprendizaje autom√°tico (machine learning) **parte de datos representados num√©ricamente**, como este vector, para que la m√°quina pueda:

- Detectar patrones.
- Agrupar ejemplos similares.
- Predecir resultados.
- Clasificar nuevas entradas.

---

### üß≠ ¬øC√≥mo se diferencia el aprendizaje supervisado del no supervisado?

#### ‚úÖ En aprendizaje supervisado:

> Cada imagen viene acompa√±ada de su **etiqueta verdadera**.  
> Por ejemplo: el vector que representa al "3" viene con la etiqueta `"3"`.

La tarea del modelo es **aprender una funci√≥n** que asocie vectores con etiquetas:

```math
f(\text{imagen}) \approx \text{etiqueta}
```

Matem√°ticamente, se busca ajustar una funci√≥n  
$f: \mathbb{R}^{64} \rightarrow \{0, 1, ..., 9\}$  
que prediga correctamente el n√∫mero que aparece en la imagen.

---

#### üîç En aprendizaje no supervisado:

> Solo tenemos los vectores.  
> No sabemos a qu√© d√≠gito corresponde cada imagen.

El objetivo es **descubrir estructura** en los datos:  
¬øExisten grupos naturales de im√°genes parecidas?  
¬øPodemos agrupar los "3" aunque no sepamos que son "3"?

Aqu√≠ no buscamos una funci√≥n de clasificaci√≥n, sino **una manera de organizar los datos**.

---

### üî¢ ¬øY qu√© rol juegan las matem√°ticas?

- El vector que representa la imagen vive en el espacio $\mathbb{R}^{64}$.
- Podemos medir **distancias** entre vectores usando geometr√≠a.
- Podemos calcular el **promedio** (centroide) de varios vectores.
- Podemos usar **√°lgebra lineal** para transformar y proyectar los datos.

Todas estas herramientas permitir√°n que la m√°quina **encuentre grupos** y **aprenda patrones**, incluso **sin saber qu√© est√° viendo**.

> Y esa ser√° la clave del resto del laboratorio:  
> **ver c√≥mo, con herramientas que ya conocen, una m√°quina puede comenzar a descubrir estructura en los datos.**
