---
title: Introducci√≥n
sidebarTitle: Introducci√≥n
---

<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex/dist/katex.css"
/>


# üß≠ Introducci√≥n: ¬øPor qu√© coordenadas polares?

> _"No todos los caminos se recorren en l√≠nea recta, ni todas las curvas se entienden bien con ejes x y y."_

En cursos anteriores hemos trabajado principalmente en el plano cartesiano, donde cada punto se representa como una pareja $(x, y)$ que indica su posici√≥n horizontal y vertical. Este sistema funciona muy bien para describir l√≠neas rectas, rect√°ngulos o incluso par√°bolas.  
Sin embargo, hay figuras y situaciones donde el uso de coordenadas cartesianas puede complicar innecesariamente los c√°lculos o la representaci√≥n gr√°fica.

Por ejemplo:

- Un **c√≠rculo** con centro en el origen requiere la ecuaci√≥n $x^2 + y^2 = r^2$, que no es lineal ni f√°cilmente integrable en muchos casos.
- Una **espiral** como la que traza un ventilador o una galaxia no se describe f√°cilmente en cartesianas.
- Una **flor** sim√©trica de varios p√©talos (como patrones en antenas o gr√°ficos polares en electr√≥nica) tiene una expresi√≥n complicada en $(x, y)$, pero puede escribirse elegantemente como $r = \cos(k\theta)$.

En estos casos, utilizar un sistema que describa directamente **distancia al origen** y **√°ngulo de orientaci√≥n** puede ser m√°s natural.


## üìå Coordenadas polares: la idea clave

En lugar de describir un punto por su desplazamiento horizontal y vertical, el sistema polar lo hace usando:

- $r$: la distancia del punto al origen.
- $\theta$: el √°ngulo (en radianes) que forma la l√≠nea del origen al punto con el eje $x$ positivo, medido en sentido antihorario.

Representamos entonces cada punto como una pareja polar:

```math
(r, \theta)
```

Por ejemplo, el punto $(1, \pi/4)$ en coordenadas polares est√° a una unidad del origen, en direcci√≥n de $45^\circ$ respecto al eje $x$.

Este cambio de perspectiva tambi√©n nos obliga a repensar c√≥mo definimos y calculamos √°reas, curvas, simetr√≠as y regiones en el plano.

> En este laboratorio exploraremos este nuevo sistema paso a paso: aprenderemos a visualizar curvas, a convertir expresiones entre sistemas y a **calcular √°reas** encerradas por curvas en coordenadas polares.

---

### üîç Visualizaci√≥n: ¬øQu√© tan natural es cada sistema?

A continuaci√≥n comparamos c√≥mo se describe y visualiza una misma curva usando coordenadas cartesianas y polares.

#### üîµ 1. C√≠rculo con centro en el origen

**En coordenadas cartesianas:** $x^2 + y^2 = 1$

```python
import numpy as np
import matplotlib.pyplot as plt

x = np.linspace(-1.1, 1.1, 400)
y = np.linspace(-1.1, 1.1, 400)
X, Y = np.meshgrid(x, y)
Z = X**2 + Y**2

plt.contour(X, Y, Z, levels=[1], colors='blue')
plt.gca().set_aspect('equal')
plt.title("C√≠rculo en coordenadas cartesianas: $x^2 + y^2 = 1$")
plt.grid(True)
plt.show()
```

**En coordenadas polares:** $r = 1$

```python
theta = np.linspace(0, 2*np.pi, 1000)
r = np.ones_like(theta)

x = r * np.cos(theta)
y = r * np.sin(theta)

plt.plot(x, y, color='green')
plt.gca().set_aspect('equal')
plt.title("C√≠rculo en coordenadas polares: $r = 1$")
plt.grid(True)
plt.show()
```

---

#### üå™Ô∏è 2. Espiral de Arqu√≠medes

**En coordenadas polares:** $r = \theta$

```python
theta = np.linspace(0, 4 * np.pi, 1000)
r = theta

x = r * np.cos(theta)
y = r * np.sin(theta)

plt.plot(x, y, color='purple')
plt.gca().set_aspect('equal')
plt.title("Espiral de Arqu√≠medes: $r = \\theta$")
plt.grid(True)
plt.show()
```

---

#### üå∏ 3. Rosa polar (4 p√©talos)

**En coordenadas polares:** $r = \cos(2\theta)$

```python
theta = np.linspace(0, 2 * np.pi, 1000)
r = np.cos(2 * theta)

x = r * np.cos(theta)
y = r * np.sin(theta)

plt.plot(x, y, color='red')
plt.gca().set_aspect('equal')
plt.title("Rosa polar: $r = \\cos(2\\theta)$")
plt.grid(True)
plt.show()
```

---

Como pueden ver, muchas curvas se expresan de forma m√°s simple y elegante en el sistema polar.  
Esto no solo facilita su visualizaci√≥n, sino tambi√©n su an√°lisis matem√°tico, como veremos m√°s adelante al calcular √°reas encerradas por estas curvas.



## üìê ¬ø√Årea bajo la curva o √°rea encerrada por la curva?

Cuando hablamos de integrales en c√°lculo, la mayor√≠a de nosotros piensa inmediatamente en esto:

```math
\int_a^b f(x)\, dx
```

Esta integral se interpreta como el **√°rea bajo la curva** $y = f(x)$, es decir, el √°rea comprendida entre la gr√°fica de la funci√≥n y el eje $x$, desde $x = a$ hasta $x = b$.

Esta interpretaci√≥n es muy √∫til cuando trabajamos con funciones expl√≠citas $y = f(x)$.  
Pero, ¬øqu√© pasa cuando tenemos **curvas m√°s complejas** que no se pueden describir as√≠?

---

### üîÑ Cambio de perspectiva: curvas cerradas

Consideremos, por ejemplo:

- Un c√≠rculo de radio 1 centrado en el origen: $x^2 + y^2 = 1$
- Una flor polar: $r = \cos(2\theta)$

Estas **no son funciones en el sentido habitual**, ya que:
- No pasan la prueba de la recta vertical.
- No se pueden escribir como $y = f(x)$ o $x = f(y)$ de forma simple.

Aun as√≠, **en ambos casos podemos preguntarnos por el √°rea encerrada por la curva**, no ‚Äúel √°rea bajo la curva‚Äù.

---

### ‚úÖ ¬øQu√© √°rea queremos calcular entonces?

- Para funciones $f(x)$ ‚Üí el √°rea bajo la curva.
- Para curvas cerradas en coordenadas polares ‚Üí el √°rea encerrada por la curva.

En coordenadas polares, usamos una f√≥rmula diferente que **acumula sectores circulares** en lugar de rect√°ngulos:

```math
A = \int_{\theta_1}^{\theta_2} \frac{1}{2} \left[r(\theta)\right]^2 \, d\theta
```

Esta f√≥rmula nos da el √°rea encerrada entre el eje polar ($\theta = 0$), la curva $r(\theta)$ y el √°ngulo $\theta$.

---

### üîç Visualizaci√≥n: ¬ø√Årea bajo o √°rea encerrada?

El siguiente c√≥digo compara visualmente:

- El √°rea **bajo** una funci√≥n $f(x)$.
- El √°rea **encerrada** por una curva polar $r(\theta)$.

```python
import numpy as np
import matplotlib.pyplot as plt

# √Årea bajo la curva y = f(x)
x = np.linspace(0, np.pi, 300)
y = np.sin(x)

plt.figure(figsize=(12, 5))

# Subplot 1: √Årea bajo f(x)
plt.subplot(1, 2, 1)
plt.plot(x, y, label=r'$y = \sin(x)$', color='blue')
plt.fill_between(x, 0, y, alpha=0.3, color='blue')
plt.title("√Årea bajo la curva $y = \sin(x)$")
plt.xlabel("x")
plt.ylabel("y")
plt.grid(True)
plt.legend()

# Subplot 2: √Årea encerrada por r = cos(2Œ∏)
theta = np.linspace(0, 2*np.pi, 1000)
r = np.cos(2 * theta)
x_p = r * np.cos(theta)
y_p = r * np.sin(theta)

plt.subplot(1, 2, 2)
plt.plot(x_p, y_p, color='red', label=r'$r = \cos(2\theta)$')
plt.fill(x_p, y_p, alpha=0.3, color='red')
plt.title("√Årea encerrada por la curva $r = \cos(2\\theta)$")
plt.axis('equal')
plt.grid(True)
plt.legend()

plt.tight_layout()
plt.show()
```

---

Como pueden ver, en el primer caso el √°rea est√° ‚Äúapoyada‚Äù sobre el eje $x$, mientras que en el segundo caso, el √°rea est√° completamente **cerrada** por la curva.  
Ambos casos requieren integraci√≥n, pero el enfoque y la f√≥rmula son diferentes.

---


### üß© ¬øQu√© estamos sumando al integrar?

La diferencia entre integrar en cartesianas y polares no es solo de notaci√≥n, tambi√©n cambia lo que sumamos.

- En coordenadas **cartesianas**, el √°rea bajo la curva se aproxima sumando **peque√±os rect√°ngulos**:
  - Base: $dx$
  - Altura: $f(x)$
  - √Årea de cada rect√°ngulo: $f(x)\,dx$

- En coordenadas **polares**, el √°rea encerrada por una curva se aproxima sumando **sectores circulares**:
  - Radio: $r(\theta)$
  - √Ångulo: $d\theta$
  - √Årea de cada sector: $\frac{1}{2} r^2(\theta)\,d\theta$

Esto explica por qu√© la f√≥rmula para el √°rea en polares incluye el factor $\frac{1}{2}$ y $r^2(\theta)$: estamos sumando pedacitos de sectores circulares


### üß† Visualizaci√≥n de rect√°ngulos vs. sectores

El siguiente gr√°fico muestra la diferencia entre ambas aproximaciones:

- A la izquierda: suma de rect√°ngulos bajo $f(x)$
- A la derecha: suma de sectores para $r(\theta)$

```python
import numpy as np
import matplotlib.pyplot as plt

fig, axs = plt.subplots(1, 2, figsize=(12, 5))

# --- Subplot 1: Aproximaci√≥n con rect√°ngulos (cartesianas)
x = np.linspace(0, np.pi, 100)
y = np.sin(x)

axs[0].plot(x, y, label=r'$y = \sin(x)$', color='blue')

# Dibujar rect√°ngulos
n = 8
x_rect = np.linspace(0, np.pi, n+1)
dx = x_rect[1] - x_rect[0]
for i in range(n):
    xi = x_rect[i]
    yi = np.sin(xi)
    axs[0].add_patch(plt.Rectangle((xi, 0), dx, yi, alpha=0.3, color='blue'))

axs[0].set_title("Suma de rect√°ngulos: √°rea bajo $f(x)$")
axs[0].set_xlabel("x")
axs[0].set_ylabel("y")
axs[0].legend()
axs[0].grid(True)

# --- Subplot 2: Aproximaci√≥n con sectores (polares)
theta = np.linspace(0, np.pi/2, 9)
r = 1 + 0.5 * np.sin(3 * theta)  # funci√≥n radial cualquiera

axs[1].set_title("Suma de sectores: √°rea encerrada por $r(\\theta)$")
axs[1].set_aspect('equal')
axs[1].grid(True)

# Dibujar sectores circulares
for i in range(len(theta) - 1):
    t1 = theta[i]
    t2 = theta[i+1]
    r_val = r[i]
    t = np.linspace(t1, t2, 30)
    rt = np.full_like(t, r_val)
    x = rt * np.cos(t)
    y = rt * np.sin(t)
    axs[1].plot(x, y, color='red')
    axs[1].fill(np.concatenate([[0], x, [0]]), np.concatenate([[0], y, [0]]), color='red', alpha=0.3)

axs[1].set_xlim(-1.5, 1.5)
axs[1].set_ylim(0, 1.5)

plt.tight_layout()
plt.show()
```

---

Esta comparaci√≥n visual te ayuda a entender **c√≥mo cambia la idea de ‚Äú√°rea‚Äù** dependiendo del sistema de coordenadas.

- En cartesianas: sumamos tiras rectangulares verticales.
- En polares: sumamos rebanadas como las de una pizza üçï

