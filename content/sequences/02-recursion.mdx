---
title: Recursi√≥n en Python
sidebarTitle: Recursi√≥n en Python
---

<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/katex/dist/katex.css"
/>


## üß© Parte 2 ‚Äî Introducci√≥n a la recursi√≥n en Python

### üéØ Objetivos de esta secci√≥n

- Comprender el concepto de recursi√≥n desde la programaci√≥n.
- Implementar funciones recursivas simples en Python.
- Comparar enfoques recursivos e iterativos para generar sucesiones.
- Conectar la definici√≥n matem√°tica de una sucesi√≥n recursiva con su implementaci√≥n computacional.

---

### üîÑ ¬øQu√© es recursi√≥n?

En programaci√≥n, una funci√≥n es **recursiva** si se llama a s√≠ misma para resolver subproblemas del problema original.

Esto es an√°logo a una definici√≥n recursiva en matem√°ticas, donde el valor de $a_n$ depende de uno o m√°s valores anteriores como $a_{n-1}$ o $a_{n-2}$.

---

### üßÆ Ejemplo: sucesi√≥n de Fibonacci

Definici√≥n matem√°tica:

$$
F_0 = 0,\quad F_1 = 1,\quad F_n = F_{n-1} + F_{n-2} \text{ para } n \geq 2
$$

Implementaci√≥n en Python (recursiva):

```python
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

# Imprimir los primeros 10 t√©rminos
for i in range(10):
    print(fibonacci(i))
```
---

### üîÅ Alternativa: versi√≥n iterativa

```python
def fibonacci_iterativo(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a

# Imprimir los primeros 10 t√©rminos
for i in range(10):
    print(fibonacci_iterativo(i))
```
---

### ‚ö†Ô∏è ¬øRecursi√≥n o iteraci√≥n?

Aunque la versi√≥n recursiva es m√°s cercana a la definici√≥n matem√°tica, es **menos eficiente**: repite muchos c√°lculos innecesarios.

Por ejemplo, para calcular `fibonacci(5)`, el c√≥digo recursivo vuelve a calcular `fibonacci(3)` varias veces. Este tipo de recursi√≥n se llama **ingenua** y se puede mejorar usando t√©cnicas como *memoizaci√≥n* (que veremos m√°s adelante si es necesario).

---

### ‚úÖ Ejemplo de recursi√≥n eficiente: factorial

No todas las recursiones son ineficientes. Hay casos donde la recursi√≥n se usa de manera directa, clara y sin duplicaci√≥n de c√°lculos.

Definici√≥n matem√°tica:

$$
n! = n \cdot (n - 1)! \quad \text{con } 0! = 1
$$

Implementaci√≥n recursiva:

```python
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)

# Ejemplo: calcular 5!
print(factorial(5))  # Imprime 120
```